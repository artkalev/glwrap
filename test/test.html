<head>
    <meta charset="UTF-8"></meta> 
    <style>
        body{
            background-color:black;
            margin:0;
            padding:0;
        }
    </style>
</head>
<body>
    <script src="../build/glwrap.js"></script>
    <script>
        let program = new glwrap.ShaderProgram();
    </script>
    <!--
    <script type="module">
        import * as mat4 from '../src/gl-matrix/mat4.js';
        import {ShaderProgram} from '../src/shaderProgram.js';
        import {Mesh, MeshAttribute} from '../src/mesh.js';
        import {Transform} from '../src/transform.js';
        import {Texture2D} from '../src/texture2D.js';
        import {Framebuffer2D} from '../src/framebuffer2D.js';
        let time = Date.now();
        let canvas = null;
        let gl = null;
        let mesh = new Mesh([ 
            new MeshAttribute(
                'position', 
                new Float32Array([ 
                     0, 1, 0,     1,-1,-1,    -1,-1,-1,
                     0, 1, 0,     1,-1, 1,     1,-1,-1,
                     0, 1, 0,    -1,-1, 1,     1,-1, 1,
                     0, 1, 0,    -1,-1,-1,    -1,-1, 1,
                    -1,-1, 1,    -1,-1,-1,     1,-1,-1,
                    -1,-1, 1,     1,-1,-1,     1,-1, 1
                ]),
                3,
                'FLOAT',
                false,
                'STATIC_DRAW'
            ),
            new MeshAttribute(
                'uv',
                new Uint8Array([
                    128,255,  0,  0,255,  0,
                    128,255,  0,  0,255,  0,
                    128,255,  0,  0,255,  0,
                    128,255,  0,  0,255,  0,
                      0,  0,  0,255,255,255,
                      0,  0,255,255,255,  0
                ]),
                2,
                'UNSIGNED_BYTE',
                true,
                'STATIC_DRAW'
            )
        ]);

        let mesh1 = new Mesh([ 
            new MeshAttribute(
                'position', 
                new Float32Array([ 
                    -1,-1,-1,  -1,-1, 1,  -1, 1, 1, //x-
                    -1,-1,-1,  -1, 1, 1,  -1, 1,-1, //x-
                     1,-1, 1,   1,-1,-1,   1, 1, 1, //x+
                     1, 1, 1,   1,-1,-1,   1, 1,-1, //x+
                    -1,-1,-1,   1, 1,-1,   1,-1,-1, //z-
                    -1,-1,-1,  -1, 1,-1,   1, 1,-1, //z-
                     1, 1, 1,  -1,-1, 1,   1,-1, 1, //z+
                    -1, 1, 1,  -1,-1, 1,   1, 1, 1, //z+
                     1,-1, 1,  -1,-1, 1,  -1,-1,-1, //y-
                     1,-1, 1,  -1,-1,-1,   1,-1,-1, //y-
                    -1, 1, 1,   1, 1, 1,  -1, 1,-1, //y+
                    -1, 1,-1,   1, 1, 1,   1, 1,-1  //y+
                ]),
                3,
                'FLOAT',
                false,
                'STATIC_DRAW'
            ),
            new MeshAttribute(
                'uv',
                new Uint8Array([
                      0,  0,255,  0,255,255,
                      0,  0,255,255,  0,255,
                    255,  0,  0,  0,255,255,
                    255,255,0,0,  0,255,
                      0,  0,255,255,255,  0,
                      0,  0,  0,255,255,255,
                    255,255,  0,  0,255,  0,
                      0,255,  0,  0,255,255,
                    255,255,  0,255,  0,  0,
                    255,255,  0,  0,255,  0,
                      0,255,255,255,  0,  0,
                      0,  0,255,255,255,  0
                ]),
                2,
                'UNSIGNED_BYTE',
                true,
                'STATIC_DRAW'
            )
        ]);

        let tex0 = new Texture2D('./textures/wave.png');
        tex0.magFilter = 'NEAREST';

        let framebuffer = new Framebuffer2D( 512,512 );
        framebuffer.colorTexture.needsUpdate = true;
        let projectionMatrix = mat4.create();
        let viewMatrix = mat4.create();
        mat4.fromTranslation( viewMatrix, [0,0,5] );
        mat4.invert(viewMatrix, viewMatrix);

        let program = new ShaderProgram(
            `
                precision lowp float;
                attribute vec3 position;
                attribute vec2 uv;
                varying vec3 v_color;
                varying vec2 v_uv;
                uniform mat4 u_modelMatrix;
                uniform mat4 u_viewMatrix;
                uniform mat4 u_projMatrix;
                void main(){
                    v_uv = uv;
                    v_color = position*0.5+0.5;
                    gl_Position = u_projMatrix * u_viewMatrix * u_modelMatrix * vec4(position, 1.0);
                }
            `,
            `
                precision lowp float;
                varying vec3 v_color;
                varying vec2 v_uv;
                uniform sampler2D u_texture;
                void main(){
                    vec4 tex = texture2D( u_texture, v_uv );
                    float grid = step( 
                        0.95,
                        max(
                            fract(v_uv.x*16.0), 
                            fract(v_uv.y*16.0)
                        )
                    );
                    
                    gl_FragColor = (tex + vec4(v_color*0.5,0.5))/1.5;
                }
            `,
            {
                u_texture : {type:'t2d', value:tex0}
            }
        );

        let obj0 = new Transform( mesh, program );
        let obj1 = new Transform( mesh, program );
        let obj2 = new Transform( mesh1, program );
        
        obj0.onupdate = function(){
            this.rotateY(0.01);
        };
        obj0.localScale.set([0.5,0.5,0.5]);
        
        obj1.localPos[0] = 1;
        obj1.localScale.set([0.25,0.25,0.25]);
        obj1.setParent(obj0);
        obj1.onupdate = function(){
            this.rotateX(0.01);
        };

        obj2.localScale.set([0.5,0.5,0.5]);
        obj2.onupdate = function(){
            this.rotateX(-0.001);
            this.rotateZ(-0.001);
        }
        obj2.uniforms.u_texture = {type:'t2d', value:framebuffer.colorTexture};

        console.log(obj0,obj1);

        function init(){
            canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            gl = canvas.getContext("webgl");
            window.addEventListener("resize", resize);
            resize();
        }

        function resize(){
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            mat4.perspective( projectionMatrix, 75, canvas.width/canvas.height, 0.1, 100.0);
        }

        function update(){
            obj0.update();
            obj1.update();
            obj2.update();
            render();
            requestAnimationFrame(update);
            time = Date.now();
        }

        function render(){
            gl.clearColor(0,0.3,0.3,1);
            framebuffer.width = 32 + (Math.sin(time*0.001)*0.5+0.5)*256;
            framebuffer.height = 32 + (Math.sin(time*0.001)*0.5+0.5)*256;
            framebuffer.needsUpdate = true;
            framebuffer.setActive(gl);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.perspective( projectionMatrix, 75, 1, 0.1, 100.0);

            obj0.draw(gl, viewMatrix, projectionMatrix);
            obj1.draw(gl, viewMatrix, projectionMatrix);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0,0,canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective( projectionMatrix, 75, canvas.width/canvas.height, 0.1, 100.0);
            obj2.draw(gl, viewMatrix, projectionMatrix);
        }

        init();
        update();
    </script>
    -->
</body>